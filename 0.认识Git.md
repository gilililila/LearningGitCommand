# Git介绍
[Git]([Git](https://git-scm.com/))是一个免费且开源的分布式版本控制系统，旨在以高效快速的方式处理从小型到大型项目的各种需求。

前往[Git Install]([Git - Install](https://git-scm.com/install/))界面，根据自己的系统按照相应的提示下载Git。

Git官方提供了一本教程[Pro Git](https://git-scm.com/book/en/v2)可以自行下载阅览。本教程基于Gemini的学习辅导Gem。

Git将文件分为了**三个区域**，分别为
- **工作区(Working Directory)**：这是你当前在电脑中看到的文件目录，包含了项目文件的某个特定版本的**检出(heckout)**，是本地的代码文件夹，里面的内容可以随意修改。就比如当前我的Obsidian笔记文件夹LearningGitCommand就是一个工作区。
- **暂存区(Staging Index)**：在Git中，这个区域通常称为**索引(Index)**。他不是一个存放文件的文件夹，而是一个二进制文件。使用git命令```git add <file>```时，Git将文件的当前内容压缩为一个二进制对象(Blob)并存入对象库。然后更新```index```文件，记录该文件名指向这个二进制对象。
- **本地仓库(Local Repository)**：本地仓库是Git的**对象数据库(Object Database)**。它存储了项目的所有历史版本。Git是一个基于内容的寻址文件系统，核心是四种对象：Blob(文件内容)、Tree(目录结构)、Commit(提交信息)、Tag(标签)。本地仓库能够永久的存储历史记录，当执行```git commit```时，Git会根据暂存区的当前状态创建一个Tree对象，然后创建一个Commit对象指向这个Tree，并将这个Commit串联到时间线上。

# 命令一览表
下面是一些常用的Git命令，之后会按照流程逐步介绍命令使用方法。
##### **Stage 1：配置与基础工作流**
[[1.配置与基础工作流]]
首先是如何建立仓库、提交高质量的代码快照以及查看状态的命令。

**⚙️环境配置**

| **Command**                                         | **Usage**                       |
| --------------------------------------------------- | ------------------------------- |
| `git config --global user.name "Your Name"`         | 设置全局用户名（开源协作的第一步）               |
| `git config --global user.email "mail@example.com"` | 设置全局邮箱（与 GitHub 账号对应）           |
| `git config --list`                                 | 查看当前 Git 的所有配置信息                |
| `git init`                                          | 在当前目录初始化一个新的 Git 仓库（生成 .git 目录） |

**📋基础工作流**

|**Command**|**Usage**|
|---|---|
|`git status`|查看工作区状态（这是最常用的命令，建议随时输入查看）|
|`git add <file>`|将指定文件添加到暂存区（Index）|
|`git add .`|将当前目录下所有变动（修改、新建）添加到暂存区|
|`git commit -m "message"`|提交暂存区内容到本地仓库，并附带描述信息|
|`git commit -am "message"`|跳过 git add 步骤，直接提交所有**已追踪**的修改（对新文件无效）|
|`git commit --amend -m "new msg"`|修改上一次提交的信息（或者补充漏掉的文件），保持提交历史整洁|

**🔍查看与对比**

|**Command**|**Usage**|
|---|---|
|`git diff`|查看**工作区**与**暂存区**之间的差异（还没 add 的内容）|
|`git diff --staged`|查看**暂存区**与**最后一次提交**之间的差异（准备 commit 的内容）|
|`git log`|查看详细的提交历史|
|`git log --oneline`|以单行简洁模式查看历史（浏览历史时的首选）|
|`git log -p <file>`|查看指定文件的每一次详细修改记录|
|`git blame <file>`|“甩锅”神器：查看文件每一行是谁在什么时候修改的|

##### **Stage 2：分支策略与冲突解决**
然后是在不影响主线的情况下开发新功能，以及在多任务间切换的命令。

**🔀分支操作**

| **Command**            | **Usage**                               |
| ---------------------- | --------------------------------------- |
| `git branch`           | 查看本地所有分支（当前分支前会有 * 号）                   |
| `git branch -a`        | 查看本地和远程的所有分支                            |
| `git branch <name>`    | 创建新分支，但不切换过去                            |
| `git switch <name>`    | 切换到指定分支（比 checkout 语义更清晰，推荐使用）          |
| `git switch -c <name>` | 创建并切换到新分支（相当于 `git checkout -b <name>`） |
| `git merge <branch>`   | 将指定分支合并到当前所在的分支                         |
| `git branch -d <name>` | 删除已合并的分支（安全删除）                          |
| `git branch -D <name>` | 强制删除分支（即使未合并，慎用）                        |

**📦现场暂存**

|**Command**|**Usage**|
|---|---|
|`git stash`|将当前未提交的工作区修改暂时“藏”起来（为了临时切换分支）|
|`git stash list`|查看所有暂存的记录|
|`git stash pop`|恢复最近一次暂存的内容，并从列表中删除|
|`git stash apply`|恢复最近一次暂存的内容，但**保留**在列表中（可重复使用）|

##### Stage 3：开源协作与工作流
然后是与GitHub交互、获取他人的代码或发布自己的代码的命令。

**📡远程连接**

|**Command**|**Usage**|
|---|---|
|`git clone <url>`|克隆远程仓库到本地（下载整个项目）|
|`git remote -v`|查看当前配置的远程仓库地址|
|`git remote add origin <url>`|关联一个远程仓库，并命名为 origin|
|`git remote remove <name>`|删除远程仓库的关联|

**🔄️同步代码**

|**Command**|**Usage**|
|---|---|
|`git pull`|拉取远程代码并自动合并到当前分支（相当于 fetch + merge）|
|`git fetch`|获取远程仓库的最新变更，但**不合并**（更安全，用于检查更新）|
|`git push`|将当前分支代码推送到远程仓库|
|`git push -u origin <branch>`|推送并设置上游关联（第一次推送新分支时使用）|
|`git fetch --prune`|获取更新并清理掉远程已经删除但在本地还存在的“僵尸”分支引用|
##### **Stage 4：历史修整与版本维护**
最后是维护干净的提交历史和错误处理的代码。

**🏷️标签与分布**

| **Command**              | **Usage**           |
| ------------------------ | ------------------- |
| `git tag`                | 列出所有标签              |
| `git tag <v1.0>`         | 给当前提交打上标签（通常用于版本发布） |
| `git push origin --tags` | 将所有本地标签一次性推送到远程     |

**🛠️撤销与修复**

|**Command**|**Usage**|
|---|---|
|`git restore <file>`|丢弃工作区的修改（撤销未 add 的文件，慎用！）|
|`git restore --staged <file>`|将文件从暂存区移出（撤销 add 操作，但不改动文件内容）|
|`git reset --soft <commit>`|回退到某次提交，保留工作区和暂存区的内容（“我只是想重写提交记录”）|
|`git reset --hard <commit>`|**危险**：彻底回退到某次提交，丢弃所有后续改动|
|`git revert <commit>`|生成一个新的提交，用来“反做”某次提交的修改（适合已经 push 的代码）|

**✒️历史重写**

|**Command**|**Usage**|
|---|---|
|`git rebase <branch>`|变基：将当前分支的修改“嫁接”到目标分支的最新提交之后（保持历史线性）|
|`git cherry-pick <commit>`|摘樱桃：将其他分支的某次特定提交复制到当前分支|
|`git reflog`|**救命神技**：查看所有操作记录（包括被回退或删除的提交都能在这里找到）|
